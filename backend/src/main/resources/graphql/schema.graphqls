scalar DateTime @specifiedBy(url: "https://scalars.graphql.org/andimarek/date-time.html")

interface Node {
    id: ID!
}

type EMailContact {
    email: String!
}

type PhoneContact {
    phone: String!
}

union Contact = EMailContact | PhoneContact

type Writer implements Node {
    id: ID!
    name: String!
    contact: Contact
}

type Comment implements Node {
    id: ID!
    text: String!

    article: Article!
}

enum Category {
    TECHNOLOGY,
    SCIENCE,
    ENVIRONMENT
}

type Image {
    uri: String!
}

type Article implements Node {
    id: ID!
    title: String!
    category: Category!
    writer: Writer!
    date: DateTime!
    body: String!
    """
    Returns an excerpt of this article, with a maximum length of `maxLength` characters.
    """
    excerpt(maxLength: Int! = 20): String!
    """
    Returns the number of words of this article.

    Note: **for demo purposes to make values more realistic, the values returned do  _not match_ the real number of words!**
    """
    wordCount: Int!
    likes: Int!

    image: Image

    # Note: in real GraphQL API comments would be pageable
    comments: [Comment!]!

}

"""
Defines all fields that can be used to sort the list of articles
"""
enum ArticleOrderBy {
    DATE, LIKES, CATEGORY
}

type ArticlesResult {
    """Number of the requested page.

    If the request doesn't specified a page, it's set to the applied default value by the server.
    """
    page: Int!
    """Size of the requested page (i.e. maximum number of `Article` objects returned)

    If the request doesn't specified a page, it's set to the applied default value by the server.
    """
    pageSize: Int!

    """
    The field that is used to sort the resulting articles from the request

    If the request doesn't specified an `orderBy`, it's set to the applied default value by the server.
    """
    orderBy: ArticleOrderBy!

    """
    Number of the next page or empty if there is no next page
    """
    nextPage: Int
    """
    Number of the previous page or empty when the returned page is the first page, so that there
    is no previous page"""
    prevPage: Int

    """
    List of articles matching the query
    """
    results: [Article!]!
}

type Query {
    # Note: in real GraphQL API you might consider Cursor-based pagination
    # see: https://relay.dev/graphql/connections.htm
    """
    Returns a list of articles
    """
    articles(
        """Specify `orderBy` when you want a sorted list.
        - If no `orderBy` is given, the list is ordered by date
        """
        orderBy: ArticleOrderBy
        """
        Defines the size of a page, i.e. the maximum number of articles returned by a query.
        - If not specified, a default sensible value on serverside will be set
        """
        pageSize: Int,
        """
        Specifies the page that should be returned. This is a 1-based index, so the first page
        is requested using `page: 1`. The amount of articles per `page` is defined by the `pageSize`
        parameter.
        - If not specified, page defaults to `1`
        """
        page: Int
    ): ArticlesResult!

    """
    Returns the `Article` with the given `articleId`.

    - If no `articleId` is provided, the _latest_ article will be returned
    - If a `articleId` is provided, but there is no article with that id, `null` is returned
    """
    article(articleId: ID): Article

    """Return all registered `Writers`"""
    writers: [Writer!]!

    node(id: ID!): Node

    """For testing the API, returns a simple string"""
    hello: String!

    """Returns a unique string for each request (for testing)"""
    uuid: String!
}

input AddCommentInput {
    articleId: ID!
    text: String!
}

type AddCommentSuccess {
    newComment: Comment!
}

type AddCommentError {
    msg: String!
}

union AddCommentPayload = AddCommentSuccess | AddCommentError

input AddLikeInput {
    articleId: ID!
}

type AddLikeSuccess {
    article: Article!
}

type AddLikeError {
    msg: String!
}

union AddLikePayload = AddLikeSuccess | AddLikeError


type Mutation {
    addComment(input: AddCommentInput!): AddCommentPayload!
    addLike(input: AddLikeInput!): AddLikePayload!
}